
```
// n表示数组array的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) {
       pos = i;
       break;
    }
  }
  return pos;
}
```

### 最好情况时间复杂度

最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度
第一次就找到  O(1)

### 最坏情况时间复杂度

最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。
第n次 找到 O(n)

### 平均情况时间复杂度
会有n+1 情况，n 种情况 + 不在数据中的情况，需要遍历的次数累加/n+1,等于平均每次 需要遍历的次数。

n个数据，就是n种情况，在加上一个不在n个数据中的情况，所以共有n+1中情况，则 1+..+n为n(n+1)/2 ，则再加个n就为n(n+3)/2 ，在除以n+1为n(n+3)/2(n+1)

> 累加求和 1+..+n为n(n+1)/2

n(n+3)/2(n+1)


### 均摊时间复杂度

在代码执行的所有复杂度情况中绝大部分是最好情况时间复杂度，个别情况是最坏情况时间复杂度且发生具有时序关系时，可以将个别最坏情况时间复杂度均摊到最好情况时间复杂度上。基本上均摊结果就等于最好情况时间复杂度。
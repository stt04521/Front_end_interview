### 计算规律

所有代码的执行时间 T(n) 与每行代码的执行次数 f(n) 成正比。

```
T(n) = O(f(n))
```
T(n): 所有代码执行的时间

f(n): 每行代码的执行次数

n 表示数据规模的大小；

公式中的O,代表 T(n) 与 f(n) 成正比

这就是大 O 时间复杂度表示法。大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度，简称时间复杂度。

### 时间复杂度 统计方法 

#### 1. 只关注循环执行次数最多的一段代码



```
function cal(n){
    var sum = 0;
    for(var i=0; i<n; i++){
        sum+=i;
    }
    return sum 
}
```

第一行代码，是常量级的执行次数，与n的大小无关，执行次数最多的是第二行第三行代码，执行了 n次。此段代码的时间复杂度 为 O(n)


> 公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。我们只需要记录一个最大量级就可以了

#### 2. 加法法则：总复杂度等于量级最大的那段代码的复杂度

```

int cal(int n) {
   int sum_1 = 0;
   int p = 1;
   for (; p < 100; ++p) {
     sum_1 = sum_1 + p;
   }

   int sum_2 = 0;
   int q = 1;
   for (; q < n; ++q) {
     sum_2 = sum_2 + q;
   }
 
   int sum_3 = 0;
   int i = 1;
   int j = 1;
   for (; i <= n; ++i) {
     j = 1; 
     for (; j <= n; ++j) {
       sum_3 = sum_3 +  i * j;
     }
   }
 
   return sum_1 + sum_2 + sum_3;
 }
```

第三段代码的 时间复杂度为 O(n2)为 最大值，整个代码片段的时间复杂度，取最大值

#### 3.乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

```

int cal(int n) {
   int ret = 0; 
   int i = 1;
   for (; i < n; ++i) {
     ret = ret + f(i);
   } 
 } 
 
 int f(int n) {
  int sum = 0;
  int i = 1;
  for (; i < n; ++i) {
    sum = sum + i;
  } 
  return sum;
 }
```

T(n) = T1(n) * T2(n) = O(n*n) = O(n2)。

几种常见时间复杂度实例分析

![统计](../img/数据结构与算法/3723793cc5c810e9d5b06bc95325bf0a.jpg)

### 多项式时间复杂度

#### O(1)
一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。

####  O(logn)、O(nlogn)

```
 i=1;
 while (i <= n)  {
   i = i * 2;
 }
```

2x=n x为执行的次数，x=log2n,所以，这段代码的时间复杂度就是 O(log2n)。

```
 i=1;
 while (i <= n)  {
   i = i * 3;
 }
```

3x=n x为执行的次数，x=log3n,所以，这段代码的时间复杂度就是 O(log3n)。

不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn)。

O(nlogn) 就很容易理解了。还记得我们刚讲的乘法法则吗？如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。而且，O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)。

#### 3. O(m+n)、O(m*n)

```
int cal(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i;
  }

  int sum_2 = 0;
  int j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j;
  }

  return sum_1 + sum_2;
}
```

m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n)。

### 空间复杂度分析 
占用内存的趋势

O(1)

```
let a = 1;
let b = 1;
let c = 1;
let d = 1;
```

很简单，O(1)

O(n)

let arr =Array(n)

看这句代码，代码中创建了一个n长度的数组，很明显数组的长度根据n来决定，所以说
O(n)

这里需要说明一下，这里没有用循环，是因为只要不是在循环里边不停的声明变量，只改变值的话是不会层架空间复杂度的


O(n²)

```
let arr=[]
for (var i = 0; i < n; i++) {
    arr[i]=i
    for (var j = 0; j < n; j++) {
        arr[i][j]=j
    }
}
```

怎么样，猛的一看这个代码是不是很刺激，我觉得如果有这种情况的话，一般都会被乱棍打死了。。。

### 创建函数

1）开辟一个堆内存

2）当函数被创建后, 其父级作用域的作用域链中的所有可变对象会被加入到它的[[scopes]]中(如果父作用域是全局, 那么当前函数的作用域链中就只会加入一个全局对象).

3）把函数体的代码，当作字符串存储在堆内存中

4）把函数堆内存的地址当旨在栈中供变量调用

> 每一个JavaScript函数都是Function对象的一个实例, 它有一个仅供JavaScript引擎存取的内部属性[[scopes]]. 这个[[scopes]]存储着一个作用域的集合, 这个集合就叫”作用域链”, 集合中存储着”可变对象”VO或”活动对象”AO(AO比VO多this和arguments属性).

### 执行函数 

1）形成一个私有上下文，上下文会进入调用栈的顶端

2）创建函数的变量对象，所谓变量对象就是用于存储在执行上下文中定义的变量和函数声明

3）复制函数的[[scopes]]属性中的对象，构建起执行环境的作用域链
    
4）this指向（this由调用者确定）

5）执行代码，该阶段中变量对象会转化为活动对象，此时活动对象中的属性都允许被访问，并且可以执行其他数据性的操作。

6）销毁执行环境和活动对象

> 活动对象：变量 函数 当前执行环境的参数。

> 活动对象 填充顺序

    1 函数参数(若有传参, 会被赋值, 若未传参, 初始化值为undefined) 

    2 函数声明

    3.变量声明(初始化变量值为undefined, 若发生命名冲突, 会忽略) 

    2 然后就到了函数的执行阶段, 此阶段当前函数中使用到的所有变量和函数声明都会从当前函数的[[Scope]]作用域链中查找, 根据作用域链中对象的位置首先会查找当前函数的AO对象, 如果没有再查找上层对象, 最后找到全局对象, 如果都没有则会报错(变量未定义).

### 执行上下文

JS的执行上下文可以理解为当前代码的执行环境，在执行JS程序时，每遇到一段JS可执行代码，都会创建一个可执行上下文。

JS当中可执行代码分为三种：全局代码、函数代码、eval代码。所以一段JS程序必定会产生多个执行上下文，而JavaScript引擎则是以堆栈的形式来对其进行管理，也就是常说的函数调用栈。栈底是全局上下文，栈顶则是当前正在执行的上下文。

> 变量对象 与活动对象的区别 

 执行上下文处于创建阶段时，变量对象中的属性是不允许被访问的，但是在进入到执行阶段后，变量对象转化为活动对象，并且里面的属性都允许被外界访问。其实两者都属于同一个对象，只是处于执行上下文的不同生命周期而已。


### 创建阶段的操作
- 创建变量对象
    - 函数环境会初始化创建Arguments对象（并赋值）
    - 函数声明（并赋值）
    - 变量声明，函数表达式声明（未赋值）
- 确定this指向（this由调用者确定）
- 确定作用域（词法环境决定，哪里声明定义，就在哪里确定）

### 执行阶段的操作
- 变量对象赋值
    - 变量赋值
    - 函数表达式赋值
- 调用函数
- 顺序执行其它代码
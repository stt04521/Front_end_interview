### 闭包的概念

闭包就是能够读取其他函数内部变量的函数。
```
function testFn() {

  var localVar = 10;  // 自由变量

  function innerFn(innerParam) {
     return  localVar += 1
  }

  return innerFn;
}

var someFn = testFn();
someFn(20)
someFn(20) // 12 
```

### 闭包的特性

- 函数嵌套函数

- 函数内部可以引用函数外部的参数和变量

- 参数和变量不会被垃圾回收机制回收

### 闭包的好处

- 保护函数内的变量安全 ，实现封装，防止变量流入其他环境发生命名冲突

- 在内存中维持一个变量，可以做缓存（但使用多了同时也是一项缺点，消耗内存）

- 匿名自执行函数可以减少内存消耗

### 垃圾回收机制

JavaScript 具有自动垃圾收集机制。执行环境会负责管理代码执行过程中使用的内存。
垃圾收集机制的原理：找出那些不再继续使用的变量，然后释放其占用的内存。
垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间），周期性地执行这一操作

#### 标记清除：
当变量进入环境，将这个变量标记为"进入环境"，当变量离开环境的时候，标记为"离开环境
"
```
function test(){
    var a = 10;    //被标记"进入环境"
    var b = "hello";    //被标记"进入环境"
}
test();    //执行完毕后之后，a和b又被标记"离开环境"，被回收
```
- 标记阶段，垃圾回收器会从根对象开始遍历。每一个可以从根对象访问到的对象都会被添加一个标识，于是这个对象就被标识为可到达对象。
- 清除阶段，垃圾回收器会对堆内存从头到尾进行线性遍历，如果发现有对象没有被标识为可到达对象，那么就将此对象占用的内存回收，并且将原来标记为可到达对象的标识清除，以便进行下一次垃圾回收操作。

JavaScript 的根对象

GC 的时候，从根对象开始遍历。在浏览器，根对象是 window；在 Node.js 中，是 global（或称为 root）.

#### 引用计数

统计引用类型变量声明后被引用的次数，当次数为 0 时，该变量将被回收

```
function func4 () {
      const c = {} // 引用类型变量 c的引用计数为 0
      let d = c // c 被 d 引用 c的引用计数为 1
      let e = c // c 被 e 引用 c的引用计数为 2
      d = {} // d 不再引用c c的引用计数减为 1
      e = null // e 不再引用 c c的引用计数减为 0 将被回收
}
```
但是引用计数的方式，有一个相对明显的缺点——循环引用

无法处理循环引用。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。

```
function func5 () {
      let f = {}
      let g = {}
      f.prop = g
      g.prop = f
      // 由于 f 和 g 互相引用，计数永远不可能为 0
}
```

#### 内存泄漏
本质上讲, 内存泄露就是不再被需要的内存, 由于某种原因, 无法被释放.

1）全局变量造成内存泄露
2）未销毁的定时器和回调函数照成内存泄露
3) 闭包照成内存泄露
4）DOM 引用照成内存泄露



[深入理解](http://newhtml.net/v8-garbage-collection/)

[垃圾回收机制较为深入理解](https://liyucang-git.github.io/2019/03/23/js%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/)


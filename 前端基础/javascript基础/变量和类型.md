### javascript 组成

- 1 ECMAScript(ES): js 的核心语法，是一种由Ecma国际（前身为欧洲计算机制造商协会，European Computer Manufacturers Association）通过ECMA-262标准化的脚本程序设计语言。

- 2 DOM： Document Object Model 文档对象模型， 提供各种api（属性和方法），让js获取或者操作页面的html元素

- 3 BOM： Browser Object Model 浏览器对象模型，提供api，让js获取浏览器信息或者操作浏览器

### ECMAScript 

JS 的语法规范，变量 数据类型，操作语句 设计模式 都是ES规范所定义的

JavaScript 由网景公司 1995年时，首次设计而成

ECMAScript 1997年 由ECMA TC39小组 推出  ECMA-262第一版 标准，2009 发布第五版 ES5 ，2015年发布 ES6 

https://blog.csdn.net/pan_junbiao/article/details/90316255

### javascript 的引入 

一般把js 引入 body的末尾：

一般情况下浏览器加载页面时，遇到script标签，回立即加载执行，会阻塞页面中其他元素的加载。

- 1 放在body后，是因为执行时，可能需要获取页面中的元素，放在body后边，可以确保元素已经加载完毕，并且不会阻塞页面的加载
- 2 放在head中，需要使用 window.onload 
- 3 asyns属性 回事script标签进行异步加载，不会阻塞页面其他元素的加载，加载完毕之后立即执行，defer属性 script标签进延迟执行，在所有元素加载完毕之后执行

### 页面渲染时 javascript 的阻塞

包含外部样式表文件和外部脚本文件的html 和渲染过程：
- 1 浏览器下载html文件并开始解析dom
- 2 遇到样式表文件link[rel=stylesheet],将其加入资源文件下载队列，继续解析dom
- 3 遇到脚本文件时，暂停dom解析并立即下载脚本文件,现代浏览器会并行加载js文件，按照书写顺序执行
- 4 下载结束后立即执行脚本，再脚本中可访问当前`<script>`以上的DOM
- 5 脚本执行结束，继续解析DOM
- 6 整个DOM解析完成，触发DOMContentLoaded事件

#### 什么是阻塞？
在页面中我们通常回引用外部文件，解析html页面从上到下解析渲染，如果head中有一个a.js 而这个文件很大，或者有问题，需要2秒加载，那么浏览器回停止渲染界面（此时是白屏显示，页面啥都没有）2s加载完成才会继续渲染

#### 为什么阻塞

由于script 可能改变dom结构，所以解析器停止生成了dom树，解析器被js阻塞，等待js文件发起http请求，然后加载，js执行完成后解析器继续解析。

#### 解决阻塞方法

- 1 推迟加载（延迟加载）
把引用外部外部文件的代码写在最后
- 2 defer 延迟加载 html4
    - defer属性表示延迟脚本的执行，等到整个文档解析完在执行
    - defer属性能延迟执行，但是不会延迟下载，浏览器遇到script就立即下载
    - 文档解析完成，脚本被执行，此时也会出发domcontentloaded事件，优先执行脚本
    - 多个标签加defer属性，执行顺序仍然是按书写顺序
```
<script src="" defer></script>
```
- 3 异步加载 html5
    - async 属性，是异步加载脚本，浏览器还能正常解析dom
    - 一定会在load事件之前执行，可能在domcontentLoaded事件之前或者之后执行
    - 异步脚步的执行顺序不定，可能不会按照书写顺序执行
```
<script src="" async></script>
```
- 4 动态加载 

```
function loadScript(url, callback){
    var script = document.createElement ("script")
    script.type = "text/javascript";
    if (script.readyState){ //IE
        script.onreadystatechange = function(){
            if (script.readyState == "loaded" || script.readyState == "complete"){
                script.onreadystatechange = null;
                callback();
            }
        };
    } else { //Others
        script.onload = function(){
            callback();
        };
    }
    script.src = url;
    document.getElementsByTagName("head")[0].appendChild(script);
}
```
- 5 XMLHttpRequesr(XHR)对象

```
var xhr = new XMLHttpRequest();
xhr.open("get","script1.js",true);
xhr.onreadystatechange = function(){
    if(xhr.readyState == 4){
        if(xhr.status>=200 && xhr.status<300 || xhr.status == 304){
            var script = document.createElement("script");
            script.type = "text/script";
            script.text = xhr.responseText;
            document.body.appendChild(script);
        }
    }
}
```

> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完全加载。

> $(document).ready() 与 window.onload 区别，前者等待dom就绪后执行，后者等待所有html关联资源，加载完成之后执行。

> css文件是并行下载的,css的下载会阻塞后面js的执行,css的下载不会阻塞后面js的下载，但是js下载完成后，被阻塞执行,js会阻止dom的解析，但是css不会阻止dom的解析。

总结：
- 1 js文件会立即下载与执行，执行完毕之后，在开始解析dom
- 2 css文件下载，不会阻止dom解析，不会阻止js下载，会阻止页面渲染，如果js文件，在css文件之后，会阻止js执行
- 3 js文件，可能会操作之前的dom节点跟css样式，因此浏览器会维持，之前的css 和js顺序，




### javascript 变量和数据类型

#### 变量 

基于ES语法规范，创建变量的6种方法：
- var （ES3）
- function（ES3）创建函数，函数名也是变量，不过储存的值是函数类型
- let
- const
- import 基于ES6 模块规范导出需要的信息
- class 基于ES6 创建类

#### 命名规范
- 严格区分大小写
- 遵循驼峰命名法：
- 数字，字母，下划线或者$命名（数字不能做为开头）
- 不能使用关键字和保留字,在 JS 中有特殊含义的叫做关键字，未来可能会成为关键字的叫做保留字

>   关键字：break、else、new、var、 case、  finally 、 return、 void 、 catch  、for  、switch 、 while 、 continue、  function  、this 、 with 、default 、 if 、 throw 、 delete 、 in 、  try 、do 、 instranceof、  typeof

> 保留字：abstract 、 enum   、int 、 short 、 boolean  、export  、interface、  static、  byte  、extends 、 long 、 super 、 char 、 final  、native  、synchronized 、 class  、float 、 package  、throws 、 const  、goto  、private 、transient 、 debugger 、 implements  、protected 、 volatile 、 double  、import  、public

#### 数据类型

- 基本数据类型：
    - 数字 number
    - 字符串 string
    - 布尔值 boolean
    - null 
    - undefined
- 引用数据类型：
    - Object
    - Array
    - RegExp
    - Date
    - Function
    - 基本包装类型
    - ...
- Symbol,唯一的值 

总共7种数据类型：undefined,null,Boolean,number,string,object,symbol

#### number
   ---

##### 整数
- 十进制
- 八进制
    - 以0开头的数值，解析为8进制数值
    - 超出范围解析为 10进制数值
- 十六进制
    - 以0x开头，解析为十六进制数值，后边跟 0-9，A-F

> 十进制转二进制，
```
    23转换 2进制 （对十进制进行除数为二的短除，直到最后商为0）
    23 / 2  商 11 余 1
    11 / 2  商 5  余 1
    5  / 2  商 2  余 1
    2  / 2  商 1  余 0
    1  / 2  商 0  余 1

    二进制 数为 10111   
```
> 二进制转十进制
```
    23转10进制(从右到左依次乘2的几次方)
    
10111
= 1 + 1*2 + 1*2*2 + 0*2*2*2 + 1*2*2*2*2
= 1 + 2 + 4 + 16 = 23
```
> 二进制就是逢二进一，十进制就是逢十进一
---
#### 浮点数
- 必须包含小数点，小数点后边至少一位数字
- 如果小数点后边没有跟数字，或者跟的只有0 会自动转换成 整数
- 科学计数法
- 精度
    - 最高精度为17位小数
    - 小数计算，精度问题 0.1+0.2 = 0.30000000000000004
- 数值范围
    - 最大数保存在 Number.MAX_VALUE中，1.7976931348623157e+308
    - 最小数值保存在 Number.MIN_VALUE中5e-324
    - 超过范围转换为 Infinity,且无法进行下次计算
    - 负数转换为 -Infinity 正值转换为 Infinity
    - 在执行极大或者极小数值计算时，必须要检查监控
> 为什么 会有精度问题，计算机 能读懂的是二进制 不是十进制 ，先把 0.1 0.2 转成十进制 来看下.
>> 0.1==》0.1.toString(2)=》0.0001100110011(无限循环..)
0.2==》0.2.toString(2)=》0.001100110011(无限循环..)
>> IEEE 754 标准的 64 位双精度浮点数的小数部分最多支持 53 位二进制位，，所以两者相加之后得到这么一串 0.0100110011001100110011001100110011001100110011001100 因浮点数小数位的限制而截断的二进制数字，这时候，我们再把它转换为十进制，就成了 0.30000000000000004。
---
NaN

> NaN: not a number ,但是是数字类型

- 用于表述本来要返回数值的操作数 未返回数值的情况
- 任何数除以0 都会返回NaN
- 任何涉及 NaN的操作，都会返回NaN
- NaN 和 任何值不相等，包括 NaN 本身
- isNaN(),判断参数是不是数值
- isNaN`` 检测机制
    - 判断需要检测时值，是不是数值类型，如果不是会默认进行转换成数值类型
```
    Number(null) => 0
    Number(undefined)=>NaN
```
- 把引用数据类型值转换为数字：先把引用值调用 toString 转换为字符串，然后再把字符串调取 Number 转换为数字
```
// [对象]
({}).toString() => '[object Object]' => NaN

// [数组]
[12,23].toString() => '12, 23' => NaN
[12].toString() => '12' => 12
[].toString() => '' => 0

// [正则]
/^$/.toString() => '/^$/' => NaN
```

检测是否有效数字：
```
    // 第一种方法
    var reg = /^(\-|\+)?(\d+.\d*|Infinity)$/;
    reg.test(num);
    // 第二种方法
    if(typeof num == "number" && !isNaN(num)){

    }
```

#### boolean
如何转换布尔类型
- Boolean
- !
- !! ( 取两次反，相当于没取反，只是转换为布尔类型，与 Boolean 方法一样)

规律：只有0 NaN 空字符串 null undefined 这五个是false 其余都是 true


#### null && undefined
都代表空或者没有
- null 空对象指针(null表示"没有对象"，即该处不应该有值。)
- undefined 未定义(undefined表示"缺少值"，就是此处应该有一个值，但是还没有定义。)
- null不是一个空引用, 而是一个原始值, 参考ECMAScript5.1中文版 4.3.11节; 它只是期望此处将引用一个对象, 注意是"期望", 

null 一般都是意料之中的，是人为手动的先赋值为 null，后面程序中我们会再次给他赋值

undefined 一般都不是人为手动控制的，大部分都是浏览器自主为空


>  ECMAScript 规范 void 操作符 对任何表达式求值都返回 undefined

>  当一个对象被赋值了null 以后，原来的对象在内存中就处于游离状态，GC 会择机回收该对象并释放内存。因此，如果需要释放某个对象，就将变量设置为null，

null 有专属的 Null 不属于 object 类型，但是 typeof null为什么  等于 'object'？

       是因为JavaScript 数据类型在底层都是以二进制的形式表示的，二进制的前三位为 0 会被 typeof 判断为对象类型，而 null 的二进制位恰好都是 0 ，因此，null 被误判断为 Object 类型。

- 000 – 对象，数据是对象的应用

- 1 – 整型，数据是31位带符号整数

- 010 – 双精度类型，数据是双精度数字

- 100 – 字符串，数据是字符串

- 110 – 布尔类型，数据是布尔值

> JavaScript的最初版本是这样区分的：null是一个表示"无"的对象，转为数值时为0；undefined是一个表示"无"的原始值，转为数值时为NaN。

> null == undefined => true
  null === undefined => false (类型不相等)

#### string

由零个或者或者多个Unicode字符串组成的字符序列

#### 字符串转换
- toString() 方法，返回相应值的字符串表现
    - 数值、布尔值、对象和字符串值都有一个 toString() 方法
    - 字符串的 toString() 方法返回字符串的一个副本
    - null 和 undefined 没有这个方法
    - 可选参数，输出数值的基数。可以输出以十进制、二进制、八进制、十六进制等的字符串值，不包含前缀 0、 0x 等
- String() 转型函数
    - 将任何类型的值转换为字符串
    - 值有 toString() 方法，则调用该方法并返回相应的结果
    - 值为 null，返回 "null"
    - 值为 undefined，返回 "undefined"
> 2.toString(); // 出错：SyntaxError 
JavaScript 解析器的一个错误， 它试图将点操作符解析为浮点数字面值的一部分。

> 解决方法：2..toString(); // 第二个点号可以正常解析
2 .toString(); // 注意点号前面的空格
(2).toString(); // 2先被计算

#### object 

   ---
在 JavaScript 中，对象的定义是“属性的集合”。属性分为数据属性和访问器属性，二者都是 key-value 结构，key 可以是字符串或者 Symbol 类型。

当我们存储的属性名不是字符串也不是数字的时候，浏览器会把这个值转换为字符串（String），然后再进行存储
   ```
   obj[{}] = 300; 
//=> 先把 ({}).toString()后的结果作为对象的属性名存储起来 obj['[object Object]'] //=> 300

obj[{}] //=> 获取的时候也是先装换为字符串 '[object Object]'，然后获取之前存储的 300
   ```
JavaScript 中的几个基本类型，都在对象类型中有一个“亲戚”。它们是：
- Number
- String
- Boolean
- Symbol

3 与 new Number(3) 是完全不同的值，它们一个是 Number 类型， 一个是对象类型。

Number、String 和 Boolean，三个构造器是两用的，当跟 new 搭配时，它们产生对象，当直接调用时，它们表示强制类型转换。Symbol 函数比较特殊，直接用 new 调用它会抛出错误，但它仍然是 Symbol 对象的构造器。

. 运算符提供了装箱操作，它会根据基础类型构造一个临时对象，使得我们能在基础类型上调用对应对象的方法。

`"abc".charAt(0)`

#### 类型判断方法
-  typeof
    - string
    - number
    - boolean
    - undefined
    - object
    - function
-  instanceof
    - 用来判断一个构造函数的原型 是否在 要检测的对象的原型链上
    - 不能判断 null,undefined
    - 基本数据类型 Number,String,Boolean 不能被判断
    - instanceof 用来判断对象是否为某一数据类型的实例，1,true,''不是实例，所以判断为false
-  constructor
    - 不能判断null,undefined,其它的都可以
    - constructor 是 Object 类型的原型属性，它能够返回当前对象的构造器（类型函数）。利用该属性，可以检测复合型数据的类型，如对象、数组和函数等。
-  Object.prototype.toString.call()





类型判断方法

```
    function getType(data){
        if( typeof data != 'object' ){
            return typeof data
        }
        return Object.prototype.toString.call(data);
    }
```




















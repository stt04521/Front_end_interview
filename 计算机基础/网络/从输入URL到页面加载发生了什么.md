
总体来说分为几个过程：

- 1. DNS 解析
- 2. TCP 连接
- 3. 发送HTTP请求
- 4. 服务器处理请求并返回 HTTP报文
- 5. 浏览器解析渲染页面
- 6. 连接结束

---

具体过程


- 1. 在浏览器地址输入 url
- 2. 判断是否有永久重定向301
    - 如果有直接跳转到对应的，url
- 3. 浏览器查看资源是否有强缓存，有则直接使用，如果是协商缓存则需要到服务器进行校验资源是否可用
    - 检验新鲜通常有两个 HTTP 头进行控制Expires和Cache-Control：
        - HTTP1.0 提供 Expires，值为一个绝对时间表示缓存新鲜日期
        - HTTP1.1 增加了 Cache-Control: max-age=,值为以秒为单位的最大新鲜时间
- 4. url解析 获取协议，主机，端口，path， 编码
        - scheme - 定义因特网服务的类型。常见的协议有 http、https、ftp、file，其中最常见的类型是 http，而 https 则是进行加密的网络传输。
        - host - 定义域主机（http 的默认主机是 www）
        - domain - 定义因特网域名，比如 w3school.com.cn
        - port - 定义主机上的端口号（http 的默认端口号是 80）
        - path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。
        - filename - 定义文档/资源的名称

        ```
            scheme://host.domain:port/path/filename
        ```


> 为什么要对URL 编码 ？ http协议中 参数组件的 传输 是key=value传递，&符号进行分隔，如果 a = val&val=1 这么传递，就会被解析为两个参数，这个时候就需要进行URL编码

> URL 针对特殊字符的各个字节(16进制)前面加上一个%

> URL路径中包含中文，编码都是采用的UTF-8

> URL查询参数中包含中文,ie低版本 操作系统编码，需要使用 encodeURIComponent

- 5. DNS解析

DNS 协议提供域名查找IP地址，或者从IP地址反查域名的服务。DNS 是 一个网络服务器

www.baidu.com 解析过程：

1 浏览器在自身缓存中，检查有没有解析过 对应的域名，如果没有命中缓存

2 操作系统中，也有域名解析过程，会进行缓存，本地DNS解析器中没有设置，会在host文件进行查找

3 路由器DNS缓存

4 本地DNS服务器（电信运营商提供，一般距离我们比较近，电脑设置的首选DNS地址）
缓存

5 本地DNS服务器，请求转发，去找根服务器（全球十三台 固定ip地址），根服务器判断出是.com 域名 是哪个域名管理

6 .com 无法解析，去找对应的 .baidu.com 解析

7 .baidu.com 服务器 返回对应的 ip地址

> 递归方式： 一路查一下，中间不反悔，等到最终结果才返回

> 迭代方式：  本地DNS服务器到根域名服务器查询的方式。

> DNS 劫持

> DNS-prefetch 优化

> 前端优化DNS的方式

- 6. TCP 连接

三次握手建立 稳定连接

第一次握手 主机A 发送位码 SYN=1，Seq=X  为 x 随机数 的tcp包 到主机B（第一次握手，由浏览器发起，告诉服务器我要发送请求了）

> SYN=1,ACK=0 表示该段报文段为连接请求报文

> x为本次TCP通信的字节流的初始序号。


第二次握手 主机B 收到请求后，发送  SYN=1， ACK=1， Seq=Y,ack=X+1的确认包 到主机A（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）

> SYN=1,ACK=1 示该报文段为连接同意的应答报文

> x为本次TCP通信的字节流的初始序号。


第三次握手 主机A 检查确认号 正确，seq 为第一次 发送的加一 ack码 为 1，向主机B 发送确认号 ACK=1 ， Seq=Z,ack = Y+1主机B，确认好之后，连接成功（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）


> 为什么是两次握手，而不是两次
防止失效的连接请求报文被服务端接收，从而产生错误

PS：失效的连接请求：若客户端向服务端发送的连接请求丢失，客户端等待应答超时后就会再次发送连接请求，此时，上一个连接请求就是『失效的』，如果接收了失效连接，会使得服务端一直在接收状态

- 7. http发送报文

HTTP请求报文是由三部分组成: 请求行, 请求报头和请求正文。

- 8. 服务器处理请求 并返回http报文

    HTTP响应报文也是由三部分组成: 状态码, 响应报头和响应报文。

    状态码
    - 1xx：指示信息–表示请求已接收，继续处理。
    - 2xx：成功–表示请求已被成功接收、理解、接受。
    - 3xx：重定向–要完成请求必须进行更进一步的操作。
    - 4xx：客户端错误–请求有语法错误或请求无法实现
    - 5xx：服务器端错误–服务器未能实现合法的请求。

响应报头

响应报文

服务器返回给浏览器的文本信息，通常HTML, CSS, JS, 图片等文件就放在这一部分。

- 9. 浏览器接收 HTTP 响应，然后根据情况选择关闭 TCP 连接或者保留重用，关闭 TCP 连接的四次挥手如下：

第一次挥手 

若A认为数据发送完成，则它需要向B发送连接释放请求。该请求只有报文头，头中携带的主要参数为： FIN=1，seq=u。此时，A将进入FIN-WAIT-1状态。

PS1：FIN=1表示该报文段是一个连接释放请求。

PS2：seq=u，u-1是A向B发送的最后一个字节的序号。
（A 告诉B 请求报文发送完毕，准备关闭）

第二次挥手

B收到连接释放请求后，会通知相应的应用程序，告诉它A向B这个方向的连接已经释放。此时B进入CLOSE-WAIT状态，并向A发送连接释放的应答，其报文头包含：
ACK=1，seq=v，ack=u+1。
（B告诉A 请求报文接收完毕，准备关闭，让A准备关闭）

PS1：ACK=1：除TCP连接请求报文段以外，TCP通信过程中所有数据报的ACK都为1，表示应答。

PS2：seq=u，u-1是A向B发送的最后一个字节的序号。

第三次挥手

当B向A发完所有数据后，向A发送连接释放请求，请求头：FIN=1，ACK=1，seq=w，ack=u+1。B便进入LAST-ACK状态。
（B告诉A 响应报文发送完，准备关闭，让A准备关闭）


第四次挥手

A收到释放请求后，向B发送确认应答，此时A进入TIME-WAIT状态。该状态会持续2MSL时间，若该时间段内没有B的重发请求的话，就进入CLOSED状态，撤销TCB。当B收到确认应答后，也便进入CLOSED状态，撤销TCB。
（A告诉B 响应报文接收完成，准备关闭，让B准备关闭）


> 前两次用于断开 A与B的连接，后两次用于断开 B与A的连接

> 第二次挥手完成后，A到B方向连接释放，B不会接收A的数据，B到A方向的连接依然存在，B可以继续向A发送数据

- 10. 浏览器解析 html 

解析 HTML 文档，构件 DOM 树，下载资源，构造 CSSOM 树，执行 js 脚本，这些操作没有严格的先后顺序，以下分别解释

- 构建 DOM 树：
    - Tokenizing：根据 HTML 规范将字符流解析为标记
    - Lexing：词法分析将标记转换为对象并定义属性和规则
    - DOM construction：根据 HTML 标记关系将对象组成 DOM 树

- 解析过程中遇到图片、样式表、js 文件，启动下载
- 构建CSSOM 树：
    - Tokenizing：字符流转换为标记流
    - Node：根据标记创建节点
    - CSSOM：节点创建 CSSOM 树
- 根据 DOM 树和 CSSOM 树构建渲染树
    - 从 DOM 树的根节点遍历所有可见节点，不可见节点包括：1）script,meta这样本身不可见的标签。2)被 css 隐藏的节点，如display: none
    - 对每一个可见节点，找到恰当的 CSSOM 规则并应用
    - 发布可视节点的内容和计算样式
- Js 解析过程
    - 浏览器创建Document 对象并解析HTML，将解析到的元素，添加到 文档中，document.readystate 为loading
    - 遇到没有 async 和 defer 的script时，直接下载，下载完之后会直接执行，阻塞解析器解析DOM，同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作 script 和他们之前的文档内容
    - 遇到 async 会异步下载，不会阻塞解析DOM，下载完成之后，直接执行，它们可以访问自己 script 和之前的文档元素
    - 当文档完成解析，document.readState 变成 interactive
    - 所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用 document.write()
    - 浏览器在 Document 对象上触发 DOMContentLoaded 事件
    - 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState 变为 complete,window 触发 load 事件
- 显示页面
























